{"articals":[{"title":"BlendMask","img":"../../../img/artical/2022-02-25-15-11-58.png","href":"ai/ai-1/0","des":"# BlendMask: Top-Down Meets Bottom-Up for Instance Segmentation\r\n\r\n## 信息\r\n文章链接：[https://arxiv.org/abs/2001.0309](https://arxiv.org/abs/2001.0309)\r\n\r\n## 创新点简介\r\n本文使用提出了blender模型，将低层信息和高层信息融合，取得了更好的效果。其中高层信息会被制作成Attention map，而低层信息则包含更多的区分细节。轻量级模型在1080Ti上可达25FPS，用COCO数据集，mAP达34.2%。\r\n\r\n\r\n## 详细内容\r\n### 模型结构\r\n![](../../../img/artical/2022-02-25-15-11-58.png)\r\n上文所说的低层信息，就是这里从骨干和FPN输出中提取出来的`Bases`，而所谓高层特征则是通过了一个个又通过了Tower之后又经过`Boxes Attns`模块的信息，他们通过Blender进行相乘，然后相加融合，最终的输出。<br/>\r\n\r\n![](../../../img/artic","commend":0,"watch":0,"evaluate":0,"date":"2022-02-25T08:49:08.002Z"},{"title":"nn","img":"","href":"ai/ai-0/0","des":"# Pytouch.nn 相关函数对照\r\n\r\n## nn.Embedding\r\n【功能】<br/>\r\n产生一组存储固定大小的词典的嵌入向量的查找表。\r\n【初始化】\r\n```py\r\nembed = torch.nn.Embedding(num_embeddings,embedding_dim)\r\n```\r\n> num_embeddings (python:int) – 词典的大小尺寸\r\n> embedding_dim (python:int) – 嵌入向量的维度，即用多少维来表示一个符号。\r\n\r\n有时在初始化时会被赋值会伴随着初始化过程。\r\n```py\r\nself.init_proposal_boxes = nn.Embedding(300, 4)\r\nnn.init.constant_(self.init_proposal_boxes.weight[:, :2], 0.5)\r\nnn.init.constant_(self.init_proposal_boxes.weight[:, 2:], 1.0)\r\n```\r\n\r\n【使用】<br />\r\n使用过程中，将`embed`直接当作向量来是使用","commend":0,"watch":0,"evaluate":0,"date":"2022-02-26T06:03:04.999Z"},{"title":"ISTR","img":"../../../img/artical/2022-02-26-14-06-17.png","href":"ai/ai-2/2","des":"# ISTR\r\n\r\n## 信息 \r\n文章链接：[https://arxiv.org/abs/2105.00637](https://arxiv.org/abs/2105.00637)\r\n\r\n发表时间：2021-05\r\n\r\n![](../../../img/artical/2022-02-26-14-06-17.png)\r\n\r\n## 创新点简介\r\n本文设计了一款TransFormer结构，类比了Spacer RCNN的思想，使用固定数目的RoI对目标进行界框检测和实例分割。\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-02-27T07:07:42.891Z"},{"title":" SSIS Metric Learning","img":"../../../img/artical/2022-02-25-15-11-58.png","href":"ai/ai-1/1","des":"# 【实例分割】Semantic Instance Segmentation via Deep Metric Learning\r\n\r\n\r\n## 信息\r\n文章链接：[https://arxiv.org/abs/1703.10277](https://arxiv.org/abs/1703.10277)\r\n\r\n## 创新点简介\r\n本文使用先计算出两个像素属于同一个目标的可能性后再聚类的方式，完成实例分割任务。`【论文原句】first computing how likely two pixels are to belong to the same object, and then by grouping similar pixels together`。具体来说论文使用全卷积的模型计算出相似度矩阵，然后通过“种子点”聚类相似像素。这些 “种子点” 是由一个全卷积网络训练出来的。\r\n\r\n\r\n## 详细内容\r\n### 模型结构\r\n![](../../../img/artical/2022-02-25-15-11-58.png)\r\n上文所说的低层信息，就是这里从骨干和FPN输出中提取出来的`Bas","commend":0,"watch":0,"evaluate":0,"date":"2022-03-05T10:06:10.261Z"},{"title":"FICS","img":"","href":"ai/ai-1/3","des":"","commend":0,"watch":0,"evaluate":0,"date":"2022-03-08T10:59:51.021Z"},{"title":"面试","img":"../../../img/artical/container_vs_vm.png","href":"docker/docker-0/4","des":"# 面试知识点\r\n\r\n## 为什么docker 运行的速度会快\r\n![](../../../img/artical/container_vs_vm.png)\r\n1. docker是os的虚拟化，而VM是硬件层的虚拟化，docker 没有了Hpyevisor（一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件）\r\n2. docker 与虚拟机相比有更少的抽象层。\r\n3. 虚拟机启动需要重新加载操作系统，而docker可以直接使用宿主机的操作系统。","commend":0,"watch":0,"evaluate":0,"date":"2022-03-09T01:34:22.853Z"},{"title":"安装","img":"","href":"docker/docker-0/0","des":"# Docker安装\r\n\r\n## Docker的意义\r\n\r\n传统的虚拟机存在着一些弊病。\r\n\r\n1. 虚拟机主体庞大：有时甚至大于你要在虚拟机上运行的应用。\r\n2. 启动时间长：虚拟机启动需要走完整的linux启动流程。\r\n3. 结构冗余：如果需要使用多个虚拟机，则其中操作系统部分虽然是一样的，但是也要单独运行。\r\n   \r\ndocker 提出了一整套的解决方案来优化和解决了这些问题\r\n1. 虚拟机主体庞大：docker 可以直接使用宿主机的操作系统，每一个docker只提供运行的必要库和应用。\r\n2. 启动时间长：由于宿主机的操作系统已被加载，所以启动docker没有启动虚拟机时加载linux的流程。\r\n3. 结构冗余：docker 将每个运行时环境进行拆分，一个docker可以运行多个依赖，而依赖之间也可以共享，解决了结构冗余的问题。\r\n\r\n> 参考地址 [https://docs.docker.com/engine/install/centos/](https://docs.docker.com/engine/install/centos/)\r\n\r\n<br>\r\n\r\n## dock","commend":0,"watch":0,"evaluate":0,"date":"2022-03-09T01:34:25.540Z"},{"title":"镜像操作","img":"","href":"docker/docker-0/2","des":"# docker 镜像使用 \r\n\r\n## 运行镜像\r\ndocker run 指令\r\n1. DockerServer会一直在后台运行，等待着客户端的命令\r\n2. 通过守护进程对容器进行操作\r\n\r\n<pre><embed type=\"image/svg+xml\" src=\"../../../img/artical/docker-architecture.svg\" /></pre>\r\n\r\n\r\n```shell\r\ndocker run [OPTIONS] imageName\r\n# -- name= \"Name\"  容器名字 比如tomcat0， tomcat1，用来区分容器\r\n# -d               后台使用\r\n# -it              使用交互的方式运行，启动并进入容器\r\n# -p               指定容器端口 -p 8080：8080\r\n#                      -p ip:主机端口:容器端口\r\n#                      -p 主机端口:容器端口\r\n#                      -p 容器端口\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-03-09T02:38:08.684Z"},{"title":"状态查询","img":"","href":"docker/docker-0/1","des":"# 【docker】查询命令\r\n\r\n## 常用命令\r\n|命令功能|命令|\r\n| --- | --- |\r\n| docker 配置信息 | docker info |\r\n| docker 版本 | docker version |\r\n| docker 版主 | docker 命令 --help |\r\n| 镜像列表 | docker images |\r\n| 镜像搜索 | docker search 镜像名 |\r\n| 正在运行 | docker ps |\r\n| 容器日志 | docker logs |\r\n\r\n\r\n## 常用位置\r\n【docker 配置文件】`/etc/docker/daemon.json`\r\n\r\n\r\n## 详情\r\n\r\n### docker images\r\n\r\n```shell\r\ndocker images -a  # 查看全部\r\ndocker images -q  # 查看id\r\ndocker images -aq # 查看全部id\r\n``` \r\n\r\n## docker ps\r\n```shell\r\ndocker ps [OPTIONS]\r\n# -a     查看全部现运行 +","commend":0,"watch":0,"evaluate":0,"date":"2022-03-09T03:29:27.645Z"},{"title":"容器操作","img":"","href":"docker/docker-0/3","des":"# 容器操作 \r\n什么是容器：容器不同于镜像，是镜像的一次运行。这里的镜像有点类似于java里的类，而容器则是类实例化的对象。\r\n\r\n## 创建容器\r\n```shell\r\ndocker run [OPTIONS] imageName\r\n# -- name= \"Name\"  容器名字 比如tomcat0， tomcat1，用来区分容器\r\n# -d               后台使用\r\n# -it              使用交互的方式运行，启动并进入容器\r\n# -p               指定容器端口 -p 8080：8080\r\n#                      -p ip:主机端口:容器端口\r\n#                      -p 主机端口:容器端口\r\n#                      -p 容器端口\r\n# -P               （P是大写）随机指定端口\r\n```\r\n【example】\r\n```shell\r\ndocker run -it centos /bin/bash  # 启动并进入centos 容器\r\n# 如果使用 do","commend":0,"watch":0,"evaluate":0,"date":"2022-03-09T03:29:30.232Z"}]}