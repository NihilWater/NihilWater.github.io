{"articals":[{"title":" SSIS Metric Learning","img":"../../../img/artical/2022-02-25-15-11-58.png","href":"ai/ai-2/1","des":"# 【实例分割】Semantic Instance Segmentation via Deep Metric Learning\r\n\r\n\r\n## 信息\r\n文章链接：[https://arxiv.org/abs/1703.10277](https://arxiv.org/abs/1703.10277)\r\n\r\n## 创新点简介\r\n本文使用先计算出两个像素属于同一个目标的可能性后再聚类的方式，完成实例分割任务。`【论文原句】first computing how likely two pixels are to belong to the same object, and then by grouping similar pixels together`。具体来说论文使用全卷积的模型计算出相似度矩阵，然后通过“种子点”聚类相似像素。这些 “种子点” 是由一个全卷积网络训练出来的。\r\n\r\n\r\n## 详细内容\r\n### 模型结构\r\n![](../../../img/artical/2022-02-25-15-11-58.png)\r\n上文所说的低层信息，就是这里从骨干和FPN输出中提取出来的`Bas","commend":0,"watch":0,"evaluate":0,"date":"2022-03-05T10:06:10.261Z"},{"title":"ISTR","img":"../../../img/artical/2022-02-26-14-06-17.png","href":"ai/ai-3/3","des":"# ISTR\r\n\r\n## 信息 \r\n文章链接：[https://arxiv.org/abs/2105.00637](https://arxiv.org/abs/2105.00637)\r\n\r\n发表时间：2021-05\r\n\r\n![](../../../img/artical/2022-02-26-14-06-17.png)\r\n\r\n## 创新点简介\r\n本文设计了一款TransFormer结构，类比了Spacer RCNN的思想，使用固定数目的RoI对目标进行界框检测和实例分割。\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-02-27T07:07:42.891Z"},{"title":"nn","img":"","href":"ai/ai-1/0","des":"# Pytouch.nn 相关函数对照\r\n\r\n## nn.Embedding\r\n【功能】<br/>\r\n产生一组存储固定大小的词典的嵌入向量的查找表。\r\n【初始化】\r\n```py\r\nembed = torch.nn.Embedding(num_embeddings,embedding_dim)\r\n```\r\n> num_embeddings (python:int) – 词典的大小尺寸\r\n> embedding_dim (python:int) – 嵌入向量的维度，即用多少维来表示一个符号。\r\n\r\n有时在初始化时会被赋值会伴随着初始化过程。\r\n```py\r\nself.init_proposal_boxes = nn.Embedding(300, 4)\r\nnn.init.constant_(self.init_proposal_boxes.weight[:, :2], 0.5)\r\nnn.init.constant_(self.init_proposal_boxes.weight[:, 2:], 1.0)\r\n```\r\n\r\n【使用】<br />\r\n使用过程中，将`embed`直接当作向量来是使用","commend":0,"watch":0,"evaluate":0,"date":"2022-02-26T06:03:04.999Z"},{"title":"基础","img":"../../../img/artical/2022-02-18-11-31-12.png","href":"ai/ai-3/0","des":"# 弱监督实例分割\r\n\r\n## 基本问题\r\n为解决人工标注实例所消耗大量时间的问题，弱监督实例分割(WSIS)利用更加简单的标签，例如检测框，图片分类标签来进行实例分割。\r\n\r\n## 标签类别\r\n弱监督标签分类通常分为以下的4种，分别是图片分类标签，边界框，点标注和涂鸦标注。 其中标注成本最小的图片分类，它仅仅提供了一张图片中所出现物品的分类信息，也叫做图像级别的标注。\r\n![](../../../img/artical/2022-02-18-11-31-12.png)\r\n\r\n\r\n## 两大问题\r\n弱监督实例分割不同于语义分割，它既要对每个像素进行分类，又要区分不同的同类个体。\r\n![](../../../img/artical/2022-02-18-19-57-14.png)\r\n1. 像素分类问题：对于没一个像素，都需要知道其属于哪一个类别，一般会使用到类激活图的方式进行分类。\r\n2. 同类物体区分问题：对于同一种类的不同个体，实例分割需要他们进行区分。常见的区分方法包括边界框区分，预测中心区分。\r\n\r\n## 经典流程\r\n一个完整的弱监督分割方法主要包含三个流程\r\n1. 配合一些扩展","commend":0,"watch":0,"evaluate":0,"date":"2022-02-25T08:42:57.069Z"},{"title":"项目结构","img":"","href":"nisown/nisown-0/2","des":"# 项目结构\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-02-17T13:41:32.129Z"},{"title":"添加点击事件","img":"../../../img/artical/2022-02-12-23-08-18.png","href":"unity/unity-0/2","des":"# unity 点击事件\r\n\r\n对于 3d 场景下物品的点击，需要使用到射线方法。\r\n\r\n## 多个重复对象的点击方法\r\n\r\n【1. 添加Layer】<br />\r\n给这些重复的物品添加相同的Layer, 这步最好在物品复制之前完成。\r\n![添加layer](../../../img/artical/2022-02-12-23-08-18.png)\r\n\r\n```c\r\nprivate void Update()\r\n{\r\n    if (Input.GetMouseButtonDown(0)) {\r\n        if (EventSystem.current.IsPointerOverGameObject() == false) {\r\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\r\n            RaycastHit hit;\r\n            bool isCollider = Physics.Raycast(ray,out hit,  1000, LayerMask","commend":0,"watch":0,"evaluate":0,"date":"2022-02-12T15:24:15.758Z"},{"title":"添加点击事件","img":"../../../img/artical/2022-02-12-23-08-18.png","href":"vue/vue-0/2","des":"# unity 点击事件\r\n\r\n对于 3d 场景下物品的点击，需要使用到射线方法。\r\n\r\n## 多个重复对象的点击方法\r\n\r\n【1. 添加Layer】<br />\r\n给这些重复的物品添加相同的Layer, 这步最好在物品复制之前完成。\r\n![添加layer](../../../img/artical/2022-02-12-23-08-18.png)\r\n\r\n```c\r\nprivate void Update()\r\n{\r\n    if (Input.GetMouseButtonDown(0)) {\r\n        if (EventSystem.current.IsPointerOverGameObject() == false) {\r\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\r\n            RaycastHit hit;\r\n            bool isCollider = Physics.Raycast(ray,out hit,  1000, LayerMask","commend":0,"watch":0,"evaluate":0,"date":"2022-02-12T15:24:15.758Z"},{"title":"输入输出","img":"","href":"unity/unity-0/0","des":"# 输入输出\r\n\r\n本文将简单描述鼠标、键盘的输入方法，以及输出文本的方法。\r\n\r\n## 前后输入\r\n\r\n```c\r\nfloat h = Input.GetAxis(\"Horizontal\");\r\nfloat v = Input.GetAxis(\"Vertical\");\r\n```\r\n\r\n## 鼠标输入\r\n\r\n```c\r\n\r\n```\r\n\r\n## 输出\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-02-12T15:16:34.675Z"},{"title":"生成","img":"","href":"unity/unity-0/1","des":"# Unity 生成\r\n\r\n## 案例：生成10 个 unity 对象，使用协程\r\n\r\n```c\r\n    void Start()\r\n    {\r\n        StartCoroutine(SpawneEnemy());\r\n    }\r\n\r\n    IEnumerator SpawneEnemy() {\r\n        foreach (Wave wave in waves) {\r\n            for (int i = 0; i < wave.count; i++) {\r\n                // GameObject.Instantiate 接收三个参数， 1. 游戏对象  2. 生成的位置  3. 生成的角度\r\n                GameObject.Instantiate(wave.enemyPrefab, START.position, Quaternion.identity);\r\n                yield return new WaitForSeconds(wave.rate);  // 生产的间隔\r\n     ","commend":0,"watch":0,"evaluate":0,"date":"2022-02-12T08:11:08.451Z"},{"title":"案例","img":"https://octodex.github.com/images/minion.png","href":"nisown/nisown-0/1","des":"---\r\n__Advertisement :)__\r\n\r\n- __[pica](https://nodeca.github.io/pica/demo/)__ - high quality and fast image\r\n  resize in browser.\r\n- __[babelfish](https://github.com/nodeca/babelfish/)__ - developer friendly\r\n  i18n with plurals support and easy syntax.\r\n\r\nYou will like those projects!\r\n\r\n---\r\n\r\n# h1 Heading 8-)\r\n## h2 Heading\r\n### h3 Heading\r\n#### h4 Heading\r\n##### h5 Heading\r\n###### h6 Heading\r\n\r\n\r\n## Horizontal Rules\r\n\r\n___\r\n\r\n---\r\n\r\n***\r\n\r\n\r\n## Typographic replacements\r\n\r\nEnable typographer","commend":0,"watch":0,"evaluate":0,"date":"2022-02-11T09:36:19.542Z"}]}