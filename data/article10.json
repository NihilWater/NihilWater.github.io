{"articles":[{"title":"initialize","img":"../../../img/article/2021-11-08-20-06-46.png","href":"ai/ai-1/4","des":"# pytorch权重初始化\r\n## 张量生成\r\n【全零张量】\r\n```py\r\ntorch.zeros((a,b,...))\r\n```\r\n\r\n\r\n## xavier 初始化\r\npytorch提供了uniform和normal两种\r\n\r\n![](../../../img/article/2021-11-08-20-06-46.png)\r\n\r\n使用normalize 进行初始化，随着网络的加深，梯度会消失。\r\n假设 $y = ax+b =w1x1+ w2x2 + ... + wnxn + b$\r\n\r\n对于y取方差有 $var(y) = var(w1x1) + var(w2x1) + var(w2x1) + var(b) = var(y) = N * var(wi) * var(xi)$\r\n所以，kaiming_normal 在初始化的时候让w在的分布都除以了$\\frac{1}{\\sqrt n}$, 来使得通过了全连接层的输出是和X同分布的。\r\n\r\n## kaiming 初始化\r\n针对ReLu 激活函数，有一般的输出，会被变成0，为了保持方差不变，会采用kaiming激活函数。在初始化的时候","commend":0,"watch":0,"evaluate":0,"date":"2022-09-16T01:00:09.825Z"},{"title":"loss","img":"","href":"ai/ai-1/5","des":"# loss 函数\r\n\r\n| 函数名         | 接口                        | 使用说明 |\r\n| -------------- | -------------------------- | -------- |\r\n| 二分类交叉熵   | torch.nn.BCELoss            | --       |\r\n| 均方差函数    | torch.nn.MSELoss()          | --       |\r\n| 平均绝对值函数 | torch.nn.L1Loss()           | --       |\r\n| 交叉熵损失函数 | torch.nn.CrossEntropyLoss() | --       |\r\n\r\n\r\n\r\n\r\n## 二次损失函数\r\n\r\n## sigmoid_focal_loss_jit\r\n```python\r\nsigmoid_focal_loss_jit(\r\n            pred,\r\n            class_target,\r\n            alpha=,\r\n      ","commend":0,"watch":0,"evaluate":0,"date":"2022-09-16T01:00:09.825Z"},{"title":"visible","img":"","href":"ai/ai-1/6","des":"# pytorch 可视化\r\n\r\n## 图片可视化\r\n```python \r\nfrom matplotlib import pyplot as plt\r\nimage = $image.cpu().clone()  # detach().numpy() 这里的 $image 要换成自己的变量名\r\n# image = image.permute(1,2,0)    # 这个是可选的，主要是要将图片的维度调正为(w, h, c)的形式\r\nplt.imshow(image)  # 准备图片\r\nplt.show()  # 展示图片\r\n```\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-09-16T01:00:09.825Z"},{"title":"resize","img":"../../../img/article/2022-04-18-21-34-43.png","href":"ai/ai-1/7","des":"\r\n\r\n![](../../../img/article/2022-04-18-21-34-43.png)\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-09-16T01:00:09.825Z"},{"title":"基础","img":"","href":"ai/ai-3/0","des":"# 目标检测算法\r\n目标检测算法，检测出一张图片上的目标物体，并通过矩形框进行标注。\r\n\r\n\r\n## 分类\r\n【是否有Anchor Box先验框】\r\n\r\n按照是否有Anchor Box先验框，可以分为Anchor-Base模型和Anchor-free模型，Anchor的提出，旨在通过先验信息，初步给出一个目标框的样子，便于模型回归。\r\nAnchor-Base的代表作是Faster-RCNN, SSD, YOLO-V2, YOLOV3;\r\nAnchor-free的代表作是YOLO-V1, FCOS\r\n\r\n【目标框选择和目标分类是否分离】\r\n\r\n按照目标框选择和目标分类是否分离, 可以分为一阶段模型和二阶段模型，one-stage 和 two-stage。\r\none-stage的代表作是YOLO，\r\ntwo-stage的代表作是Faster-RCNN","commend":0,"watch":0,"evaluate":0,"date":"2022-09-16T01:00:09.825Z"},{"title":"FCOS","img":"","href":"ai/ai-3/1","des":"# FCOS\r\n\r\n## 基础信息\r\n\r\n文章标题：FCOS: Fully Convolutional One-Stage Object Detection \r\n\r\n文章链接：[https://arxiv.org/pdf/1904.01355.pdf](https://arxiv.org/pdf/1904.01355.pdf)\r\n\r\n发表时间：2019-04\r\n\r\n\r\n## 背景\r\n\r\n\r\n## 创新点简介\r\n\r\n\r\n## 问题\r\n存在的问题，使用每一个预测框里的像素进行分类和预测，会导致背景参与计算，这样的运算是没有意义的。甚至是无效的。\r\n问题疑点：考虑到感受野的问题，肯能边上的特征像素也能够完成对物品框边缘的预测，尤其是边缘像素更有可能包含了物体边缘的信息，要小心处理\r\n\r\n\r\n## 引用","commend":0,"watch":0,"evaluate":0,"date":"2022-09-16T01:00:09.825Z"}]}