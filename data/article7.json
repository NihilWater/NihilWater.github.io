{"articles":[{"title":"基础","img":"","href":"ai/ai-3/0","des":"# 目标检测算法\r\n目标检测算法，检测出一张图片上的目标物体，并通过矩形框进行标注。\r\n\r\n\r\n## 分类\r\n【是否有Anchor Box先验框】\r\n\r\n按照是否有Anchor Box先验框，可以分为Anchor-Base模型和Anchor-free模型，Anchor的提出，旨在通过先验信息，初步给出一个目标框的样子，便于模型回归。\r\nAnchor-Base的代表作是Faster-RCNN, SSD, YOLO-V2, YOLOV3;\r\nAnchor-free的代表作是YOLO-V1, FCOS\r\n\r\n【目标框选择和目标分类是否分离】\r\n\r\n按照目标框选择和目标分类是否分离, 可以分为一阶段模型和二阶段模型，one-stage 和 two-stage。\r\none-stage的代表作是YOLO，\r\ntwo-stage的代表作是Faster-RCNN","commend":0,"watch":0,"evaluate":0,"date":"2022-04-05T07:17:26.781Z"},{"title":"FCOS","img":"","href":"ai/ai-3/1","des":"# FCOS\r\n\r\n## 基础信息\r\n\r\n文章标题：FCOS: Fully Convolutional One-Stage Object Detection \r\n\r\n文章链接：[https://arxiv.org/pdf/1904.01355.pdf](https://arxiv.org/pdf/1904.01355.pdf)\r\n\r\n发表时间：2019-04\r\n\r\n\r\n## 背景\r\n\r\n\r\n## 创新点简介\r\n\r\n\r\n## 问题\r\n存在的问题，使用每一个预测框里的像素进行分类和预测，会导致背景参与计算，这样的运算是没有意义的。甚至是无效的。\r\n问题疑点：考虑到感受野的问题，肯能边上的特征像素也能够完成对物品框边缘的预测，尤其是边缘像素更有可能包含了物体边缘的信息，要小心处理\r\n\r\n\r\n## 引用","commend":0,"watch":0,"evaluate":0,"date":"2022-04-05T07:17:26.781Z"},{"title":"安装","img":"","href":"ai/ai-1/0","des":"# 安装\r\n\r\n## 版本匹配列表\r\n\r\n版本对照表：[https://pytorch.org/get-started/previous-versions/](https://pytorch.org/get-started/previous-versions/)\r\n\r\n\r\n下载链接：[https://download.pytorch.org/whl/torch_stable.html](https://download.pytorch.org/whl/torch_stable.html)\r\n\r\n\r\n|   pytorch   | torchvision |  torchaudio |\r\n| ----------- | ----------- | ----------- |\r\n|    1.9.0    |    0.10.0   |    0.9.0    |\r\n|    1.8.1    |    0.9.1    |    0.8.1    |\r\n|    1.8.0    |    0.9.0    |    0.8.0    |\r\n|    1.7.1    |    0.8.","commend":0,"watch":0,"evaluate":0,"date":"2022-04-05T07:17:26.780Z"},{"title":"nn","img":"","href":"ai/ai-1/1","des":"# Pytouch.nn 相关函数对照\r\n\r\n## nn.Embedding\r\n【功能】<br/>\r\n产生一组存储固定大小的词典的嵌入向量的查找表。\r\n【初始化】\r\n```py\r\nembed = torch.nn.Embedding(num_embeddings,embedding_dim)\r\n```\r\n> num_embeddings (python:int) – 词典的大小尺寸\r\n> embedding_dim (python:int) – 嵌入向量的维度，即用多少维来表示一个符号。\r\n\r\n有时在初始化时会被赋值会伴随着初始化过程。\r\n```py\r\nself.init_proposal_boxes = nn.Embedding(300, 4)\r\nnn.init.constant_(self.init_proposal_boxes.weight[:, :2], 0.5)\r\nnn.init.constant_(self.init_proposal_boxes.weight[:, 2:], 1.0)\r\n```\r\n\r\n【使用】<br />\r\n使用过程中，将`embed`直接当作向量来是使用","commend":0,"watch":0,"evaluate":0,"date":"2022-04-05T07:17:26.780Z"},{"title":"MatrixOpration","img":"","href":"ai/ai-1/3","des":"# 常用pytorch矩阵操作\r\n| 操作 | 指令 | 备注 |\r\n|-----|-----|-----|\r\n| 从list转变 | torch.cat($list) | 往往这类操作后面接列表生成式|\r\n| 获取邻域 |F.unfold( x, kernel_size=kernel_size, padding=padding, dilation=dilation ) | kernel_size领域大小，padding边距，dilation填充，padding = (kernel_size + (dilation - 1) * (kernel_size - 1)) // 2|\r\n| 邻域->图像 |F.fold( x, kernel_size=kernel_size, padding=padding, dilation=dilation ) | kernel_size领域大小，padding边距，dilation填充，padding = (kernel_size + (dilation - 1) * (kernel_size - 1)) // 2|\r\n|出现过的量|torch.uni","commend":0,"watch":0,"evaluate":0,"date":"2022-04-05T07:17:26.780Z"},{"title":"coco数据集","img":"","href":"ai/ai-0/0","des":"# coco 数据集介绍\r\n\r\nMS COCO的全称是Microsoft Common Objects in Context ，COCO数据集是微软构建的一个数据集，其中包含丰富的物体检测，分割和关键点数据。这个数据集以场景理解为目标，与PASCAL VOC数据集相比，COCO中的数据集从复杂的日常场景中截取，背景更为复杂，目标数量比较多且目标尺寸更小，因此在COCO数据集上的实现好的效果更为困难。到目前为止，拥有最大的图像分割数据集，一共存在80个标注类别，有超过33 万张图片，其中20 万张有标注，整个数据集中个体的数目超过150 万个。","commend":0,"watch":0,"evaluate":0,"date":"2022-04-05T07:17:26.779Z"},{"title":"regularization正则化 copy","img":"../../../img/article/2021-10-29-23-50-14.png","href":"ai/ai-0/1","des":"# 正则化\r\n## 定义\r\n&emsp;&emsp;正则化在深度学习的训练中，往往起到一个规范模型结构的作用，比如为了让模型防止发生过拟合，提高泛化能力，我们会通过加入正则项来完成对高次分量的抑制。其中防止过拟合也会被称为减小结构风险。\r\n\r\n![过拟合，正常，欠拟合效果](../../../img/article/2021-10-29-23-50-14.png)\r\n\r\n&emsp;&emsp;[维基百科](https://en.wikipedia.org/wiki/Regularization_(mathematics))中这么定义：在数学、统计学、金融、 计算机科学中，特别是在机器学习和逆问题中，正则化是添加信息以解决不适定问题或防止过度拟合的过程。正则化可以应用于不适定优化问题中的目标函数。正则化项或惩罚项对优化函数施加了成本，以使最优解唯一。\r\n\r\n\r\n## 范数\r\n&emsp;&emsp;范数的起源是用来比较两个向量之间的大小，比较标量的大小十分容易，比较张量就需要我们将张量以某种形式的计算，变成标量，从而进行比较，范数的作用就是这个可以完成向量到标量计算的函数。\r\n范数的一","commend":0,"watch":0,"evaluate":0,"date":"2022-04-05T07:17:26.779Z"},{"title":"loss函数","img":"","href":"ai/ai-0/2","des":"# Loss 函数\r\nloss 函数用来衡量结果和预期之间的差距，为梯度下降给定优化方向。\r\n\r\n## 如何设计\r\n一个好的loss函数，可以让任务更好更高效的训练，举一下几个例子。\r\n1. 正则项：在Loss函数中设计正则项，可以有效的防止过拟合现象。<br/> \r\n   $$Loss = loss(y,\\hat{y}) + ||w||_{p}$$\r\n\r\n2. Focal Loss: 通过设计平衡因子，完成正负样本均衡，以及偏向对困难样本的训练<br/> \r\n$$ L_{fl}=\\left\\{\r\n\\begin{array}{rcl}\r\n-\\alpha (1-y)^{\\gamma}log(y')      &      & \\text{y=1(T)}\\\\\r\n-(1-\\alpha )(y')^{ \\gamma }log(1-y')  &      & \\text{y=0(F)}\r\n\\end{array} \\right. $$\r\n\r\n\r\n    $\\alpha$表示了正负样本的均衡，如果$\\alpha$越大，则Loss对于正样本越敏感。\r\n    $\\gamma$表示了对错误分类的惩罚力度","commend":0,"watch":0,"evaluate":0,"date":"2022-04-05T07:17:26.779Z"}]}