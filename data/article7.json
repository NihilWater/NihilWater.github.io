{"articles":[{"title":"DANet","img":"../../../img/article/2022-02-18-17-29-10.png","href":"ai/ai-4/2","des":"# DANet \r\n\r\n## 基础信息\r\n\r\n文章标题：Dual Attention Network for Scene Segmentation\r\n\r\n文章链接：[https://arxiv.org/abs/1809.02983](https://arxiv.org/abs/1809.02983)\r\n\r\n发表时间：2018-09\r\n\r\n\r\n## 创新点简介\r\n本文使用自注意力机制，在语义分割上加入了位置自注意力机制和通道自注意力机制，根据作者表述，位置自注意力机制将图片中相似的内容进行互相增强`【原文：any two positions with similar features can contribute mutual improvement regardless of their distance in spatial dimension】`，而通道自注意力机制则可以捕获任意通道之间的互相依赖关系。`【原文：we use the similar self-attention mechanism to capture the channel dependencies betwee","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.800Z"},{"title":"基础","img":"../../../img/article/2021-11-03-13-35-03.png","href":"ai/ai-5/0","des":"# 基础\r\n语义分割是对图像中的每个像素划分出对应的类别，实现像素级别的分类。实例分割是在语义分割的基础上，进一步分割已划分类别的具体对象，即分割出实例。\r\n\r\n![](../../../img/article/2021-11-03-13-35-03.png)\r\n\r\n## 实例分割算法存在的挑战\r\n引用2016年InstanceCut中的话，实例分割存在着4个问题：\r\n1. 像语义分割一样将每个实例作为一种分类是没有意义的，如“第五个汽车”类。\r\n2. 一张图像中的实例数目差别很大，以城市景观数据集为例，每张图片可能存在0-120个不等的目标实例。 \r\n3. 实例分割相比于目标检测，需要更多的数进行表达，而不是仅仅中心点和长宽，4个值。\r\n4. 实例分割相比语义分割，需要更加细致的标签。\r\n\r\n## 实例分割和语义分割\r\n1. 能否完全使用语义分割？\r\n\r\n   不行，由于目标数目不固定，不能让一个实例就是一个类别。一般思路是先进行目标检测，后对检测狂内的物体进行语义分割，判断检测框内语义分割结果与哪个实例掩膜最接近就认为是哪实例。\r\n\r\n2. 存在的问题：两个实例重叠\r\n   \r\n ","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.800Z"},{"title":"基础","img":"","href":"ai/ai-3/0","des":"# 目标检测算法\r\n目标检测算法，检测出一张图片上的目标物体，并通过矩形框进行标注。\r\n\r\n\r\n## 分类\r\n【是否有Anchor Box先验框】\r\n\r\n按照是否有Anchor Box先验框，可以分为Anchor-Base模型和Anchor-free模型，Anchor的提出，旨在通过先验信息，初步给出一个目标框的样子，便于模型回归。\r\nAnchor-Base的代表作是Faster-RCNN, SSD, YOLO-V2, YOLOV3;\r\nAnchor-free的代表作是YOLO-V1, FCOS\r\n\r\n【目标框选择和目标分类是否分离】\r\n\r\n按照目标框选择和目标分类是否分离, 可以分为一阶段模型和二阶段模型，one-stage 和 two-stage。\r\none-stage的代表作是YOLO，\r\ntwo-stage的代表作是Faster-RCNN","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.799Z"},{"title":"FCOS","img":"","href":"ai/ai-3/1","des":"# FCOS\r\n\r\n## 基础信息\r\n\r\n文章标题：FCOS: Fully Convolutional One-Stage Object Detection \r\n\r\n文章链接：[https://arxiv.org/pdf/1904.01355.pdf](https://arxiv.org/pdf/1904.01355.pdf)\r\n\r\n发表时间：2019-04\r\n\r\n\r\n## 背景\r\n\r\n\r\n## 创新点简介\r\n\r\n\r\n## 问题\r\n存在的问题，使用每一个预测框里的像素进行分类和预测，会导致背景参与计算，这样的运算是没有意义的。甚至是无效的。\r\n问题疑点：考虑到感受野的问题，肯能边上的特征像素也能够完成对物品框边缘的预测，尤其是边缘像素更有可能包含了物体边缘的信息，要小心处理\r\n\r\n\r\n## 引用","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.799Z"},{"title":"sparse_RCNN","img":"../../../img/article/2022-03-15-15-25-43.png","href":"ai/ai-3/2","des":"# Sparse RCNN\r\n\r\n## 基础信息\r\n\r\n论文题目：Sparse R-CNN: End-to-End Object Detection with Learnable Proposals\r\n\r\n论文链接：[https://arxiv.org/abs/2011.12450](https://arxiv.org/abs/2011.12450)\r\n\r\n发表时间：2020-11\r\n\r\n## 创新\r\n\r\n使用可学习的100-300个边框来取代RPN（区域建议网络），实现了一个完全稀疏的端到端目标检测网络。\r\n\r\n\r\n## 详情\r\n\r\n### 稀疏和密集\r\n![](../../../img/article/2022-03-15-15-25-43.png)\r\n\r\n作者指出以前的目标检测都是每个特征像素做的，采用了“anchor boxes”机制，这会有十分密集的目标框（HWk个）产生，Faster RCNN 使用NMS筛选值的计算分类和边框回归的建议框，让一个密集的检测变得稀疏起来，但他仍然不能算是一个完全稀疏的目标检测方法（图b）。而本文作者所提出的Sparse RCNN则使用学习来的","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.799Z"},{"title":"MatrixOpration","img":"","href":"ai/ai-1/3","des":"# 常用pytorch矩阵操作\r\n| 操作 | 指令 | 备注 |\r\n|-----|-----|-----|\r\n| 从list转变 | torch.cat($list) | 往往这类操作后面接列表生成式|\r\n| 获取邻域 |F.unfold( x, kernel_size=kernel_size, padding=padding, dilation=dilation ) | kernel_size领域大小，padding边距，dilation填充，padding = (kernel_size + (dilation - 1) * (kernel_size - 1)) // 2|\r\n| 邻域->图像 |F.fold( x, kernel_size=kernel_size, padding=padding, dilation=dilation ) | kernel_size领域大小，padding边距，dilation填充，padding = (kernel_size + (dilation - 1) * (kernel_size - 1)) // 2|\r\n|出现过的量|torch.uni","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.798Z"},{"title":"initialize","img":"../../../img/article/2021-11-08-20-06-46.png","href":"ai/ai-1/4","des":"# pytorch权重初始化\r\n## 张量生成\r\n【全零张量】\r\n```py\r\ntorch.zeros((a,b,...))\r\n```\r\n\r\n\r\n## xavier 初始化\r\npytorch提供了uniform和normal两种\r\n\r\n![](../../../img/article/2021-11-08-20-06-46.png)\r\n\r\n使用normalize 进行初始化，随着网络的加深，梯度会消失。\r\n假设 $y = ax+b =w1x1+ w2x2 + ... + wnxn + b$\r\n\r\n对于y取方差有 $var(y) = var(w1x1) + var(w2x1) + var(w2x1) + var(b) = var(y) = N * var(wi) * var(xi)$\r\n所以，kaiming_normal 在初始化的时候让w在的分布都除以了$\\frac{1}{\\sqrt n}$, 来使得通过了全连接层的输出是和X同分布的。\r\n\r\n## kaiming 初始化\r\n针对ReLu 激活函数，有一般的输出，会被变成0，为了保持方差不变，会采用kaiming激活函数。在初始化的时候","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.798Z"},{"title":"loss","img":"","href":"ai/ai-1/5","des":"# loss 函数\r\n\r\n## 二次损失函数\r\n\r\n## sigmoid_focal_loss_jit\r\n```python\r\nsigmoid_focal_loss_jit(\r\n            pred,\r\n            class_target,\r\n            alpha=,\r\n            gamma=,\r\n            reduction=\"sum\"\r\n        )\r\n```\r\n\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.798Z"},{"title":"visible","img":"","href":"ai/ai-1/6","des":"# pytorch 可视化\r\n\r\n## 图片可视化\r\n```python \r\nfrom matplotlib import pyplot as plt\r\nimage = $image.cpu().clone()  # detach().numpy() 这里的 $image 要换成自己的变量名\r\n# image = image.permute(1,2,0)    # 这个是可选的，主要是要将图片的维度调正为(w, h, c)的形式\r\nplt.imshow(image)  # 准备图片\r\nplt.show()  # 展示图片\r\n```\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.798Z"},{"title":"安装","img":"","href":"ai/ai-1/0","des":"# 安装\r\n\r\n## 版本匹配列表\r\n\r\n版本对照表：[https://pytorch.org/get-started/previous-versions/](https://pytorch.org/get-started/previous-versions/)\r\n\r\n\r\n下载链接：[https://download.pytorch.org/whl/torch_stable.html](https://download.pytorch.org/whl/torch_stable.html)\r\n\r\n\r\n|   pytorch   | torchvision |  torchaudio |\r\n| ----------- | ----------- | ----------- |\r\n|    1.9.0    |    0.10.0   |    0.9.0    |\r\n|    1.8.1    |    0.9.1    |    0.8.1    |\r\n|    1.8.0    |    0.9.0    |    0.8.0    |\r\n|    1.7.1    |    0.8.","commend":0,"watch":0,"evaluate":0,"date":"2022-04-12T06:46:01.797Z"}]}