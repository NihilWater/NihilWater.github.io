{"articles":[{"title":"SSIS Metric Learning","img":"../../../img/article/2022-02-25-15-11-58.png","href":"ai/ai-3/3","des":"# 【实例分割】Semantic Instance Segmentation via Deep Metric Learning\r\n\r\n\r\n## 信息\r\n文章链接：[https://arxiv.org/abs/1703.10277](https://arxiv.org/abs/1703.10277)\r\n\r\n发表时间：2017-10\r\n\r\n## 创新点简介\r\n本文使用先计算出两个像素属于同一个目标的可能性后再聚类的方式，完成实例分割任务。`【论文原句】first computing how likely two pixels are to belong to the same object, and then by grouping similar pixels together`。具体来说论文使用全卷积的模型计算出相似度矩阵，然后通过“种子点”聚类相似像素。这些 “种子点” 是由一个全卷积网络训练出来的。\r\n\r\n\r\n## 详细内容\r\n### 模型结构\r\n![](../../../img/article/2022-02-25-15-11-58.png)\r\n上文所说的低层信息，就是这里从骨干","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.487Z"},{"title":"loss","img":"","href":"ai/ai-1/3","des":"# loss 函数\r\n\r\n## 二次损失函数\r\n\r\n## sigmoid_focal_loss_jit\r\n```python\r\nsigmoid_focal_loss_jit(\r\n            pred,\r\n            class_target,\r\n            alpha=,\r\n            gamma=,\r\n            reduction=\"sum\"\r\n        )\r\n```\r\n\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.486Z"},{"title":"visible","img":"","href":"ai/ai-1/4","des":"# pytorch 可视化\r\n\r\n## 图片可视化\r\n```python \r\nfrom matplotlib import pyplot as plt\r\nimage = $image.cpu().clone()  # detach().numpy() 这里的 $image 要换成自己的变量名\r\n# image = image.permute(1,2,0)    # 这个是可选的，主要是要将图片的维度调正为(w, h, c)的形式\r\nplt.imshow(image)  # 准备图片\r\nplt.show()  # 展示图片\r\n```\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.486Z"},{"title":"GraphCut","img":"../../../img/article/2022-03-22-16-52-40.png","href":"ai/ai-2/0","des":"# GraphCut\r\n\r\n## 信息\r\n\r\n文章标题：Interactive Graph Cuts for Optimal Boundary & Region Segmentation of Objects in N-D Images\r\n\r\n文章链接：[https://www.csd.uwo.ca/~yboykov/Papers/iccv01.pdf](https://www.csd.uwo.ca/~yboykov/Papers/iccv01.pdf)\r\n\r\n发表时间：2001-07\r\n\r\n\r\n## 背景\r\n\r\n## 创新点简介\r\n用户标记部分像素作为“目标”或“背景”，为图像分割提供硬约束。此外，利用图像的边缘信息和区域信息作为软约束。图割方法是一种全局最优的N维图像分割方法。Graph cuts是一种能量优化算法，应用于前背景分割。它把图像分割问题当作图的最小割（min cut）问题。\r\n![](../../../img/article/2022-03-22-16-52-40.png)\r\n\r\n## 详细内容\r\n![](../../../img/article/2022-03-22","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.486Z"},{"title":"DANet","img":"../../../img/article/2022-02-18-17-29-10.png","href":"ai/ai-2/1","des":"# DANet \r\n\r\n## 信息\r\n\r\n文章标题：Dual Attention Network for Scene Segmentation\r\n\r\n文章链接：[https://arxiv.org/abs/1809.02983](https://arxiv.org/abs/1809.02983)\r\n\r\n发表时间：2018-09\r\n\r\n\r\n## 创新点简介\r\n本文使用自注意力机制，在语义分割上加入了位置自注意力机制和通道自注意力机制，根据作者表述，位置自注意力机制将图片中相似的内容进行互相增强`【原文：any two positions with similar features can contribute mutual improvement regardless of their distance in spatial dimension】`，而通道自注意力机制则可以捕获任意通道之间的互相依赖关系。`【原文：we use the similar self-attention mechanism to capture the channel dependencies between ","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.486Z"},{"title":"loss函数","img":"","href":"ai/ai-0/2","des":"# Loss 函数\r\nloss 函数用来衡量结果和预期之间的差距，为梯度下降给定优化方向。\r\n\r\n## 如何设计\r\n一个好的loss函数，可以让任务更好更高效的训练，举一下几个例子。\r\n1. 正则项：在Loss函数中设计正则项，可以有效的防止过拟合现象。<br/> \r\n   $$Loss = loss(y,\\hat{y}) + ||w||_{p}$$\r\n\r\n2. Focal Loss: 通过设计平衡因子，完成正负样本均衡，以及偏向对困难样本的训练<br/> \r\n$$ L_{fl}=\\left\\{\r\n\\begin{array}{rcl}\r\n-\\alpha (1-y)^{\\gamma}log(y')      &      & \\text{y=1(T)}\\\\\r\n-(1-\\alpha )(y')^{ \\gamma }log(1-y')  &      & \\text{y=0(F)}\r\n\\end{array} \\right. $$\r\n\r\n\r\n    $\\alpha$表示了正负样本的均衡，如果$\\alpha$越大，则Loss对于正样本越敏感。\r\n    $\\gamma$表示了对错误分类的惩罚力度","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.485Z"},{"title":"nn","img":"","href":"ai/ai-1/0","des":"# Pytouch.nn 相关函数对照\r\n\r\n## nn.Embedding\r\n【功能】<br/>\r\n产生一组存储固定大小的词典的嵌入向量的查找表。\r\n【初始化】\r\n```py\r\nembed = torch.nn.Embedding(num_embeddings,embedding_dim)\r\n```\r\n> num_embeddings (python:int) – 词典的大小尺寸\r\n> embedding_dim (python:int) – 嵌入向量的维度，即用多少维来表示一个符号。\r\n\r\n有时在初始化时会被赋值会伴随着初始化过程。\r\n```py\r\nself.init_proposal_boxes = nn.Embedding(300, 4)\r\nnn.init.constant_(self.init_proposal_boxes.weight[:, :2], 0.5)\r\nnn.init.constant_(self.init_proposal_boxes.weight[:, 2:], 1.0)\r\n```\r\n\r\n【使用】<br />\r\n使用过程中，将`embed`直接当作向量来是使用","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.485Z"},{"title":"MatrixOpration","img":"","href":"ai/ai-1/1","des":"# 常用pytorch矩阵操作\r\n| 操作 | 指令 | 备注 |\r\n|-----|-----|-----|\r\n| 从list转变 | torch.cat($list) | 往往这类操作后面接列表生成式|\r\n| 获取邻域 |F.unfold( x, kernel_size=kernel_size, padding=padding, dilation=dilation ) | kernel_size领域大小，padding边距，dilation填充，padding = (kernel_size + (dilation - 1) * (kernel_size - 1)) // 2|\r\n| 邻域->图像 |F.fold( x, kernel_size=kernel_size, padding=padding, dilation=dilation ) | kernel_size领域大小，padding边距，dilation填充，padding = (kernel_size + (dilation - 1) * (kernel_size - 1)) // 2|\r\n|出现过的量|torch.uni","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.485Z"},{"title":"initialize","img":"../../../img/article/2021-11-08-20-06-46.png","href":"ai/ai-1/2","des":"# pytorch权重初始化\r\n## 张量生成\r\n【全零张量】\r\n```py\r\ntorch.zeros((a,b,...))\r\n```\r\n\r\n\r\n## xavier 初始化\r\npytorch提供了uniform和normal两种\r\n\r\n![](../../../img/article/2021-11-08-20-06-46.png)\r\n\r\n使用normalize 进行初始化，随着网络的加深，梯度会消失。\r\n假设 $y = ax+b =w1x1+ w2x2 + ... + wnxn + b$\r\n\r\n对于y取方差有 $var(y) = var(w1x1) + var(w2x1) + var(w2x1) + var(b) = var(y) = N * var(wi) * var(xi)$\r\n所以，kaiming_normal 在初始化的时候让w在的分布都除以了$\\frac{1}{\\sqrt n}$, 来使得通过了全连接层的输出是和X同分布的。\r\n\r\n## kaiming 初始化\r\n针对ReLu 激活函数，有一般的输出，会被变成0，为了保持方差不变，会采用kaiming激活函数。在初始化的时候","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.485Z"},{"title":"coco数据集","img":"","href":"ai/ai-0/0","des":"# coco 数据集介绍\r\n\r\nMS COCO的全称是Microsoft Common Objects in Context ，COCO数据集是微软构建的一个数据集，其中包含丰富的物体检测，分割和关键点数据。这个数据集以场景理解为目标，与PASCAL VOC数据集相比，COCO中的数据集从复杂的日常场景中截取，背景更为复杂，目标数量比较多且目标尺寸更小，因此在COCO数据集上的实现好的效果更为困难。到目前为止，拥有最大的图像分割数据集，一共存在80个标注类别，有超过33 万张图片，其中20 万张有标注，整个数据集中个体的数目超过150 万个。","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T09:39:56.484Z"}]}