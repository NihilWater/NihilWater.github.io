{"articles":[{"title":"镜像操作","img":"","href":"docker/docker-0/2","des":"# docker 镜像使用 \r\n\r\n## 运行镜像\r\ndocker run 指令\r\n1. DockerServer会一直在后台运行，等待着客户端的命令\r\n2. 通过守护进程对容器进行操作\r\n\r\n<pre><embed type=\"image/svg+xml\" src=\"../../../img/article/docker-architecture.svg\" /></pre>\r\n\r\n\r\n```shell\r\ndocker run [OPTIONS] imageName\r\n# -- name= \"Name\"  容器名字 比如tomcat0， tomcat1，用来区分容器\r\n# -d               后台使用\r\n# -it              使用交互的方式运行，启动并进入容器\r\n# -p               指定容器端口 -p 8080：8080\r\n#                      -p ip:主机端口:容器端口\r\n#                      -p 主机端口:容器端口\r\n#                      -p 容器端口\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.035Z"},{"title":"容器操作","img":"","href":"docker/docker-0/3","des":"# 容器操作 \r\n什么是容器：容器不同于镜像，是镜像的一次运行。这里的镜像有点类似于java里的类，而容器则是类实例化的对象。\r\n\r\n## 创建容器\r\n```shell\r\ndocker run [OPTIONS] imageName\r\n# -- name= \"Name\"  容器名字 比如tomcat0， tomcat1，用来区分容器\r\n# -d               后台使用\r\n# -it              使用交互的方式运行，启动并进入容器\r\n# -p               指定容器端口 -p 8080：8080\r\n#                      -p ip:主机端口:容器端口\r\n#                      -p 主机端口:容器端口\r\n#                      -p 容器端口\r\n# -P               （P是大写）随机指定端口\r\n```\r\n【example】\r\n```shell\r\ndocker run -it centos /bin/bash  # 启动并进入centos 容器\r\n# 如果使用 do","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.035Z"},{"title":"面试","img":"../../../img/article/container_vs_vm.png","href":"docker/docker-0/4","des":"# 面试知识点\r\n\r\n## 为什么docker 运行的速度会快\r\n![](../../../img/article/container_vs_vm.png)\r\n1. docker是os的虚拟化，而VM是硬件层的虚拟化，docker 没有了Hpyevisor（一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件）\r\n2. docker 与虚拟机相比有更少的抽象层。\r\n3. 虚拟机启动需要重新加载操作系统，而docker可以直接使用宿主机的操作系统。","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.035Z"},{"title":"Can Vision Transformers Learn without Natural Images","img":"","href":"ai/ai-9/0","des":"# Vision Transformers Learn without Natural Images\r\n\r\n\r\n## 摘要\r\n\r\n【函数驱动的监督学习】使用了 FDSL,(Formula-Driven Supervised Learning)函数驱动的监督学习。先前的FDSL主要是产生了形状不同的形状的图形的物体，进行训练。在本文中作者又引入了颜色和斑块来进行训练。\r\n\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.034Z"},{"title":"introduction","img":"","href":"ai/ai-10/0","des":"# 图卷积神经网络\r\n## 意义\r\n使用神经网络来表达一张图上的信息。图相较于其他的数据结构，存在更加明显的结构特性。一张图的信息包含有4个方面，顶点的信息，边的信息，图整体的信息，图的连接信息。如今，大部分GNN在做的事情就是以一张图片的这些信息作为输入，得到一张输出图，输出图的结构信息与原图一样，但是顶点信息，边信息，整张图的信息表达会发生改变。\r\n\r\n## 信息的表达\r\n对于顶点信息，我们可以使用一个向量来进行表示。\r\n\r\n对于每一条边，我们同样可以使用一个向量来表示。\r\n对于全局信息，我们可以使用所有点的均值与所有边的均值进行表示，也可以使用一个和全部节点相连接的伪节点进行信息的表达。\r\n对于连接性，我们可以使用邻接表或者邻接矩阵来表示。\r\n\r\n## 案例说明\r\n【顶点分类问题】：已知一张图上有若干节点，需要对这些节点进行分类。\r\n① 最简单的方式，可能我们已经有了节点的向量表达，所以只需要对每个节点做一次全连接+softmax之类的分类网络就可以表示信息了。\r\n② 信息转化，假设顶点没有合理的向量表达，或者表达能力较弱，我们可以用边的","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.034Z"},{"title":"安装","img":"","href":"docker/docker-0/0","des":"# Docker安装\r\n\r\n## Docker的意义\r\n\r\n传统的虚拟机存在着一些弊病。\r\n\r\n1. 虚拟机主体庞大：有时甚至大于你要在虚拟机上运行的应用。\r\n2. 启动时间长：虚拟机启动需要走完整的linux启动流程。\r\n3. 结构冗余：如果需要使用多个虚拟机，则其中操作系统部分虽然是一样的，但是也要单独运行。\r\n   \r\ndocker 提出了一整套的解决方案来优化和解决了这些问题\r\n1. 虚拟机主体庞大：docker 可以直接使用宿主机的操作系统，每一个docker只提供运行的必要库和应用。\r\n2. 启动时间长：由于宿主机的操作系统已被加载，所以启动docker没有启动虚拟机时加载linux的流程。\r\n3. 结构冗余：docker 将每个运行时环境进行拆分，一个docker可以运行多个依赖，而依赖之间也可以共享，解决了结构冗余的问题。\r\n\r\n> 参考地址 [https://docs.docker.com/engine/install/centos/](https://docs.docker.com/engine/install/centos/)\r\n\r\n<br>\r\n\r\n## dock","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.034Z"},{"title":"状态查询","img":"","href":"docker/docker-0/1","des":"# 【docker】查询命令\r\n\r\n## 常用命令\r\n|命令功能|命令|\r\n| --- | --- |\r\n| docker 配置信息 | docker info |\r\n| docker 版本 | docker version |\r\n| docker 版主 | docker 命令 --help |\r\n| 镜像列表 | docker images |\r\n| 镜像搜索 | docker search 镜像名 |\r\n| 正在运行 | docker ps |\r\n| 容器日志 | docker logs |\r\n\r\n\r\n## 常用位置\r\n【docker 配置文件】`/etc/docker/daemon.json`\r\n\r\n\r\n## 详情\r\n\r\n### docker images\r\n\r\n```shell\r\ndocker images -a  # 查看全部\r\ndocker images -q  # 查看id\r\ndocker images -aq # 查看全部id\r\n``` \r\n\r\n## docker ps\r\n```shell\r\ndocker ps [OPTIONS]\r\n# -a     查看全部现运行 +","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.034Z"},{"title":"SETR","img":"../../../img/article/2022-03-11-14-59-06.png","href":"ai/ai-7/0","des":"# SETR\r\n\r\n## 信息\r\n\r\n论文题目：Rethinking Semantic Segmentation from a Sequence-to-Sequence Perspective with Transformers\r\n\r\n文章链接：[https://arxiv.org/abs/2012.15840](https://arxiv.org/abs/2012.15840)\r\n\r\n发表时间：2020-12 \r\n\r\n## 创新点简介\r\nSETR使用transformer设计了一个端到端的语义分割网络，首先将原图切割为若干 16x16 个窗口，把其中的像素进行线性映射，得到一维编码，然后使用24层transformer的编码器来完成对于图像特征的提取，然后使用卷积做上采样操作，得到最终结果。\r\n\r\n![](../../../img/article/2022-03-11-14-59-06.png)\r\n\r\n## 优点\r\n是语义分割领域的一次创行，将transformer引入到了语义分割领域中。\r\n\r\n## 存在的问题\r\n切割的窗口过大，语义信息不仅准。\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.033Z"},{"title":"基础","img":"","href":"ai/ai-8/0","des":"# 目标检测算法\r\n目标检测算法，检测出一张图片上的目标物体，并通过矩形框进行标注。\r\n\r\n\r\n## 分类\r\n【是否有Anchor Box先验框】<br/>\r\n\r\n按照是否有Anchor Box先验框，可以分为Anchor-Base模型和Anchor-free模型，Anchor的提出，旨在通过先验信息，初步给出一个目标框的样子，便于模型回归。\r\nAnchor-Base的代表作是Faster-RCNN, SSD, YOLO-V2, YOLOV3;\r\nAnchor-free的代表作是YOLO-V1, FCOS\r\n\r\n【目标框选择和目标分类是否分离】<br/>\r\n\r\n按照目标框选择和目标分类是否分离, 可以分为一阶段模型和二阶段模型，one-stage 和 two-stage。\r\none-stage的代表作是YOLO，\r\ntwo-stage的代表作是Faster-RCNN","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.033Z"},{"title":"FCOS","img":"","href":"ai/ai-8/1","des":"# FCOS\r\n\r\n## 信息\r\n\r\n文章标题：FCOS: Fully Convolutional One-Stage Object Detection \r\n\r\n文章链接：[https://arxiv.org/pdf/1904.01355.pdf](https://arxiv.org/pdf/1904.01355.pdf)\r\n\r\n发表时间：2019-04\r\n\r\n\r\n## 背景\r\n\r\n\r\n## 创新点简介\r\n\r\n\r\n## 问题\r\n存在的问题，使用每一个预测框里的像素进行分类和预测，会导致背景参与计算，这样的运算是没有意义的。甚至是无效的。\r\n问题疑点：考虑到感受野的问题，肯能边上的特征像素也能够完成对物品框边缘的预测，尤其是边缘像素更有可能包含了物体边缘的信息，要小心处理\r\n\r\n\r\n## 引用","commend":0,"watch":0,"evaluate":0,"date":"2022-03-25T10:41:49.033Z"}]}