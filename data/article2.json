{"articles":[{"title":"字母样式","img":"","href":"markdown/markdown-0/1","des":"# markdown 字母样式","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.214Z"},{"title":"简介","img":"../../../img/article/pic1.png","href":"nisown/nisown-0/0","des":"# NiWeb\r\n\r\n## 主要思想\r\n\r\n   React 以其组件化的思想，为大家提供了良好的编程体验，在我们编写自己的博客时，如果能很好的使用这种编程逻辑，我们就可以写出更加灵活的，可扩展性强的博客。如果你也是这么想的，请和我一起发展这个项目吧。与Hexo相比，React在生成静态界面的同时，保留了react 特有的虚拟dom 和 diff 算法，让你博客的响应速度出人一等。\r\n\r\n## 主要板块\r\n\r\n    经过作者的长期观察，一般的博客网站可以划分为一下几个结构\r\n    1. 首页\r\n        1.0 导航栏\r\n        1.1 首页的大图，这一部分，往往博主会放一张图片和一些文字，来提升博客整体的丰富度\r\n        1.2 首页的文章列表，文章列表主要是文章的访问数据，标题，描述和配图\r\n        1.3 首页的底部, 在中国的网站至少会有备案信息\r\n    2. 文章展示\r\n\r\n    3. 历史档案\r\n\r\n## 更新说明\r\n\r\n- 2021 年 3 月 7 日：完成前端首页整体布局\r\n    ![首页整体布局](../../../img/ar","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.214Z"},{"title":"案例","img":"https://octodex.github.com/images/minion.png","href":"nisown/nisown-0/1","des":"---\r\n__Advertisement :)__\r\n\r\n- __[pica](https://nodeca.github.io/pica/demo/)__ - high quality and fast image\r\n  resize in browser.\r\n- __[babelfish](https://github.com/nodeca/babelfish/)__ - developer friendly\r\n  i18n with plurals support and easy syntax.\r\n\r\nYou will like those projects!\r\n\r\n---\r\n\r\n# h1 Heading 8-)\r\n## h2 Heading\r\n### h3 Heading\r\n#### h4 Heading\r\n##### h5 Heading\r\n###### h6 Heading\r\n\r\n\r\n## Horizontal Rules\r\n\r\n___\r\n\r\n---\r\n\r\n***\r\n\r\n\r\n## Typographic replacements\r\n\r\nEnable typographer","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.214Z"},{"title":"nvm","img":"","href":"env/env-0/0","des":"\r\n\r\n## NVM 常见命令\r\n```shell\r\nnvm install stable ## 安装最新稳定版 node\r\nnvm install <version> ## 安装指定版本\r\nnvm uninstall <version> ## 删除已安装的指定版本\r\nnvm use <version> ## 切换使用指定的版本node\r\nnvm ls ## 列出所有安装的版本\r\nnvm ls-remote ## 列出所有远程服务器的版本\r\nnvm current ## 显示当前的版本\r\nnvm alias <name> <version> ## 给不同的版本号添加别名\r\nnvm unalias <name> ## 删除已定义的别名\r\nnvm reinstall-packages <version> ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包\r\nnvm alias default [node版本号] ##设置默认版本\r\n```\r\n\r\n\r\n## npm 查看所有全局\r\n```shell\r\ncnpm list -g --depth 0\r\n```","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.213Z"},{"title":"镜像操作","img":"","href":"docker/docker-0/2","des":"# docker 镜像使用 \r\n\r\n## 运行镜像\r\ndocker run 指令\r\n1. DockerServer会一直在后台运行，等待着客户端的命令\r\n2. 通过守护进程对容器进行操作\r\n\r\n<pre><embed type=\"image/svg+xml\" src=\"../../../img/article/docker-architecture.svg\" /></pre>\r\n\r\n\r\n```shell\r\ndocker run [OPTIONS] imageName\r\n# -- name= \"Name\"  容器名字 比如tomcat0， tomcat1，用来区分容器\r\n# -d               后台使用\r\n# -it              使用交互的方式运行，启动并进入容器\r\n# -p               指定容器端口 -p 8080：8080\r\n#                      -p ip:主机端口:容器端口\r\n#                      -p 主机端口:容器端口\r\n#                      -p 容器端口\r\n","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.211Z"},{"title":"容器操作","img":"","href":"docker/docker-0/3","des":"# 容器操作 \r\n什么是容器：容器不同于镜像，是镜像的一次运行。这里的镜像有点类似于java里的类，而容器则是类实例化的对象。\r\n\r\n## 创建容器\r\n```shell\r\ndocker run [OPTIONS] imageName\r\n# -- name= \"Name\"  容器名字 比如tomcat0， tomcat1，用来区分容器\r\n# -d               后台使用\r\n# -it              使用交互的方式运行，启动并进入容器\r\n# -p               指定容器端口 -p 8080：8080\r\n#                      -p ip:主机端口:容器端口\r\n#                      -p 主机端口:容器端口\r\n#                      -p 容器端口\r\n# -P               （P是大写）随机指定端口\r\n```\r\n【example】\r\n```shell\r\ndocker run -it centos /bin/bash  # 启动并进入centos 容器\r\n# 如果使用 do","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.211Z"},{"title":"面试","img":"../../../img/article/container_vs_vm.png","href":"docker/docker-0/4","des":"# 面试知识点\r\n\r\n## 为什么docker 运行的速度会快\r\n![](../../../img/article/container_vs_vm.png)\r\n1. docker是os的虚拟化，而VM是硬件层的虚拟化，docker 没有了Hpyevisor（一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件）\r\n2. docker 与虚拟机相比有更少的抽象层。\r\n3. 虚拟机启动需要重新加载操作系统，而docker可以直接使用宿主机的操作系统。","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.211Z"},{"title":"安装","img":"","href":"docker/docker-0/0","des":"# Docker安装\r\n\r\n## Docker的意义\r\n\r\n传统的虚拟机存在着一些弊病。\r\n\r\n1. 虚拟机主体庞大：有时甚至大于你要在虚拟机上运行的应用。\r\n2. 启动时间长：虚拟机启动需要走完整的linux启动流程。\r\n3. 结构冗余：如果需要使用多个虚拟机，则其中操作系统部分虽然是一样的，但是也要单独运行。\r\n   \r\ndocker 提出了一整套的解决方案来优化和解决了这些问题\r\n1. 虚拟机主体庞大：docker 可以直接使用宿主机的操作系统，每一个docker只提供运行的必要库和应用。\r\n2. 启动时间长：由于宿主机的操作系统已被加载，所以启动docker没有启动虚拟机时加载linux的流程。\r\n3. 结构冗余：docker 将每个运行时环境进行拆分，一个docker可以运行多个依赖，而依赖之间也可以共享，解决了结构冗余的问题。\r\n\r\n> 参考地址 [https://docs.docker.com/engine/install/centos/](https://docs.docker.com/engine/install/centos/)\r\n\r\n<br>\r\n\r\n## dock","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.210Z"},{"title":"状态查询","img":"","href":"docker/docker-0/1","des":"# 【docker】查询命令\r\n\r\n## 常用命令\r\n|命令功能|命令|\r\n| --- | --- |\r\n| docker 配置信息 | docker info |\r\n| docker 版本 | docker version |\r\n| docker 版主 | docker 命令 --help |\r\n| 镜像列表 | docker images |\r\n| 镜像搜索 | docker search 镜像名 |\r\n| 正在运行 | docker ps |\r\n| 容器日志 | docker logs |\r\n\r\n\r\n## 常用位置\r\n【docker 配置文件】`/etc/docker/daemon.json`\r\n\r\n\r\n## 详情\r\n\r\n### docker images\r\n\r\n```shell\r\ndocker images -a  # 查看全部\r\ndocker images -q  # 查看id\r\ndocker images -aq # 查看全部id\r\n``` \r\n\r\n## docker ps\r\n```shell\r\ndocker ps [OPTIONS]\r\n# -a     查看全部现运行 +","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.210Z"},{"title":"sparse_RCNN","img":"../../../img/article/2022-03-15-15-25-43.png","href":"ai/ai-8/3","des":"# Sparse RCNN\r\n\r\n## 信息\r\n\r\n论文题目：Sparse R-CNN: End-to-End Object Detection with Learnable Proposals\r\n\r\n论文链接：[https://arxiv.org/abs/2011.12450](https://arxiv.org/abs/2011.12450)\r\n\r\n发表时间：2020-11\r\n\r\n## 创新\r\n\r\n使用可学习的100-300个边框来取代RPN（区域建议网络），实现了一个完全稀疏的端到端目标检测网络。\r\n\r\n\r\n## 详情\r\n\r\n### 稀疏和密集\r\n![](../../../img/article/2022-03-15-15-25-43.png)\r\n\r\n作者指出以前的目标检测都是每个特征像素做的，采用了“anchor boxes”机制，这会有十分密集的目标框（HWk个）产生，Faster RCNN 使用NMS筛选值的计算分类和边框回归的建议框，让一个密集的检测变得稀疏起来，但他仍然不能算是一个完全稀疏的目标检测方法（图b）。而本文作者所提出的Sparse RCNN则使用学习来的N(","commend":0,"watch":0,"evaluate":0,"date":"2022-03-26T11:32:39.209Z"}]}